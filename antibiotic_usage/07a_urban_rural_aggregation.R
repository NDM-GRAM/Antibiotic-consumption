#### i. Setup ####

core_repo         <- '/share/code/geospatial/annieb6/lbd_core/'
indicator_group   <- 'antibiotics'
indicator         <- 'cough_antibiotics'
run_date          <- '2020_02_15_03_49_34'
raked             <- FALSE
pop_measure       <- 'a0004t'
age               <- 0
holdout           <- 0
shapefile_version <- '2019_12_12'

share_dir <- paste0("/share/geospatial/mbg/",indicator_group,"/",indicator,"/output/",run_date,"/")

# Load limited and specific MBG functions
mbg_functions <- c('mbg_functions.R', 'prep_functions.R',
                   'covariate_functions.R', 'misc_functions.R',
                   'post_estimation_functions.R', 'gbd_functions.R',
                   'shiny_functions.R', 'holdout_functions.R',
                   'categorical_variable_functions.R', 'validation_functions.R',
                   'seegMBG_transform_functions.R', 'shapefile_functions.R')
source(paste0(core_repo, '/mbg_central/setup.R'))
source_functions(paste(core_repo, 'mbg_central', mbg_functions, sep = '/'))

# Load limited and specific R packages
load_R_packages(c('foreign', 'rgeos', 'data.table','raster','rgdal','INLA',
                  'seegSDM', 'seegMBG', 'plyr', 'dplyr'))

# my_regions <- c("dia_cssa", "dia_wssa", "dia_malay+dia_oceania", "dia_mid_east", "dia_essa+dia_sssa-syc", "dia_mcaca", "dia_central_asia+kaz+mng", "dia_afr_horn", "balkans_ext+caucasus", "dia_se_asia", "dia_south_asia", "dia_s_america-tto")
reg <- commandArgs()[4]
# for(reg in my_regions){
  pathaddin         <-paste0('_bin',age,'_',reg,'_',holdout)
  
# Load pre-run image so config parameters are available as function argument defaults
load(paste0('/share/geospatial/mbg/', indicator_group, '/', indicator, '/model_image_history/pre_run_tempimage_', run_date, pathaddin,'.RData'))

# get year_list from the config file
this_config <- fread(paste0(share_dir, '/config.csv'))
year_list <- this_config[V1 == 'year_list', V2]
if (is.character(year_list)) year_list <- eval(parse(text = year_list))

# These are where draw-level, admin-level results will be stored
message("Starting empty lists for results")
regions<-list()
admin_0<-list()
admin_1<-list()
admin_2<-list()
sp_hierarchy_list<-list()

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Looping through Regions, aggregating data to Admin Units
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Loading Data
load(paste0(share_dir, indicator, "_cell_draws_eb", pathaddin, ".RData"))

# Getting the simple polygon and simple raster objects for this region alone
simple_polygon_list <- load_simple_polygon(gaul_list = get_adm0_codes(reg, shapefile_version = shapefile_version),
                                           buffer = 0.4, subset_only = FALSE,
                                           shapefile_version = shapefile_version)
subset_shape   <- simple_polygon_list[[1]]
simple_polygon <- simple_polygon_list[[2]]
raster_list    <- build_simple_raster_pop(subset_shape, link_table = NULL)
simple_raster  <- raster_list[['simple_raster']]
pop_raster     <- raster_list[['pop_raster']]
rm(raster_list,simple_polygon_list,pop_raster);gc()

# Determining a list of the valid pixel indices based on the simple raster template
pixel_id <- seegSDM:::notMissingIdx(simple_raster)
pixel_spatial<-data.table(pixel_id=pixel_id)

# Pulling Population
pop <- load_worldpop_covariate(template_raster = simple_polygon,
                               pop_measure = pop_measure,
                               pop_release = pop_release,
                               start_year = min(year_list),
                               end_year = max(year_list),
                               interval = 12)
pop<-crop_set_mask(pop[[1]],simple_raster)
pop <- data.table(extract(pop, pixel_id)) # getting the pixels from the population raster that correspond to the valid pixels in the pop-raster
pop[,pixel_id:=pixel_id]
pop<-melt(pop,id.vars="pixel_id") # Melting the dataframe such that it is long () and should match the number of rows in cell_pred
pop[, year := (min(year_list) - 1) + as.numeric(gsub("worldpop.", "", variable))] # Converting "worldpop.1" variables to actual years.
pop<-pop[,list(pixel_id,year,pop=value)] # Subsetting columns
pop[is.na(pop),pop:=0] # Setting values where pop is NA to 0


#load in the urbanicity layer
urban_config <- fixed_effects_config[14]
loader <- MbgStandardCovariateLoader$new(start_year = min(year_list),
                                         end_year = max(year_list),
                                         interval = as.numeric(interval_mo),
                                         covariate_config = urban_config)
urbanicity <- loader$get_covariates(simple_polygon)
urbanicity <-crop_set_mask(urbanicity[[1]],simple_raster) #crop to region
urbanicity <- data.table(extract(urbanicity, pixel_id)) # getting the pixels from the population raster that correspond to the valid pixels in the pop-raster
urbanicity[,pixel_id:=pixel_id] #reshape long and generate ID to correspond to simple raster
urbanicity <-melt(urbanicity,id.vars="pixel_id") # Melting the dataframe such that it is long () and should match the number of rows in cell_pred
urbanicity[, year := (min(year_list) - 1) + as.numeric(gsub("ghslurbanicity.", "", variable))] # Converting "worldpop.1" variables to actual years.
urbanicity <-urbanicity[,list(pixel_id,year,urbanicity=value)] # Subsetting columns
urbanicity[is.na(urbanicity),urbanicity:=0] # Setting values where urbanicity is NA to 0 (rural)

# Loading and Assigning Admin Units to Pixels
# Defining a function that will get the raster versions of each Admin level:
region_adm0_list<-get_adm0_codes(reg, shapefile_version = shapefile_version) # Getting the adm0 GAUL codes, we can use this to make sure we don't accidentally include countries from buffers that shouldn't be in this region

GetAdmin<-function(admin_level,simple_raster, region_adm0_list, shapefile_version){
  message(paste0("Loading admin level ",admin_level))
  
  # load admin shape file
  admin_shp <- rgdal::readOGR(dsn=get_admin_shapefile(admin_level, version = shapefile_version))
  
  # ensure that the rasterize variable is a numeric
  admin_shp@data[[paste0('ADM', admin_level, '_CODE')]] <- as.numeric(as.character(admin_shp@data[[paste0('ADM', admin_level, '_CODE')]]))
  
  # if it doesn't exist, get areas of polygons. 
  if(is.null(admin_shp$Shape_Area)){
    admin_shp$Shape_Area <- area(admin_shp) / 1e6 ## TODO
  }
  
  message("Rasterizing with the custom function...")
  # we order by area so small places don't get buried under big places (e.g. Lesotho and S. Africa)
  admin_rast<-rasterize_check_coverage(admin_shp[order(admin_shp$Shape_Area),],simple_raster,paste0("ADM",admin_level,"_CODE"), fun="first", link_table = NULL)
  
  message("Converted to raster based on simple_raster template. Cropping and masking:")
  admin_rast  <- crop(admin_rast, extent(simple_raster))
  admin_rast  <- setExtent(admin_rast, simple_raster)
  admin_rast  <- mask(admin_rast, simple_raster)
  
  message("Subsetting polygon and point objects to only contain the relevant ADM0 codes; calculating centroids.")
  admin_shp<-admin_shp[admin_shp@data$ADM0_CODE %in% region_adm0_list,]
  admin_centroids<-SpatialPointsDataFrame(gCentroid(admin_shp, byid=TRUE), admin_shp@data, match.ID=FALSE)
  
  message("Compiling and returning results.")
  admin<-list()
  admin[["spdf"]]<-admin_shp
  admin[["centroids"]]<-admin_centroids
  admin[["rast"]]<-admin_rast
  admin[["attributes"]]<-copy(data.table(admin_shp@data))
  
  return(admin)
}

message("Rasterizing shapefiles; this may take a while.")
admin_levels<-list() # Emtpy list of levels that will be filled with admin levels
for(lvl in c(0,1,2)){
  fieldname<-paste0("ADM",lvl,"_CODE")
  admin_info<-GetAdmin(admin_level=lvl,simple_raster,region_adm0_list, shapefile_version = shapefile_version)
  pixel_spatial[[fieldname]]<-extract(admin_info[["rast"]],pixel_spatial$pixel_id) # Generate a field based on the admin boundary unit that has the ID code in the pixel_spatial data.table
  admin_levels[[as.character(lvl)]]<-admin_info # Add the admin info to the list
  if(sum(is.na(pixel_spatial[[fieldname]]))>0){ # Check to see if any of the pixels don't have a location assigned
    message(paste0("   Whoah, there are some pixels that are NA, and have not been assigned a location for level ",lvl))
  }
}


# Merging together cell_pred and spatial info, population info and urbanicity info
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
pop<-merge(pop,pixel_spatial,by="pixel_id",all.x=T) # Merging on the spatial information to the population information.
# merge on urbanicity
pop<-merge(pop,urbanicity,by=c("pixel_id", "year"),all.x=T) # Merging on the spatial information to the population information.
pop<-pop[order(year,pixel_id)] # Re-ordering the pop object by year such that pixels ascent, and years ascend (same as cell_pred)
cell_pred<-data.table(cell_pred) # Converting cell_pred to a data.table
draw_colnames<-names(cell_pred)

rm(urbanicity)
cell_pred<-cbind(cell_pred,pop) # Adding on the population and spatial information to cell_pred.


# Split out the urban and rural pixels
cell_pred_urban <- cell_pred[cell_pred$urbanicity == 1,]
cell_pred_rural <- cell_pred[cell_pred$urbanicity == 0,]

pop_urban <- pop[urbanicity == 1]
pop_rural <- pop[urbanicity == 0,]

admin_levels_spare <- admin_levels
# Loading and Assigning Pixels to Admin Units (that are missing) - ???? NOT REALLY SURE WHAT THE RESULTS OF THIS IS
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# We now need to figure out what admin units don't show up when we pull the locations of individual raster pixels of our results.
# To do this, we need to know what Admin 1 and 2 units exist in the shapefiles we want to use, but don't show up in the results.

message("Generating a raster of the pixel_id values")
pixel_id_raster<-copy(simple_raster)
for (pix in pixel_id){ # For each of the valid pixels, replace the value with the pixel_id, not whatever country ID is used in the simple_polygon/raster
  pixel_id_raster@data@values[pix]<-pix
}

missing_admins<-list() # This will contain the cell_preds for otherwise missing admin units, by level.
for(lvl in c(0,1,2)){
  fieldname<-paste0("ADM",lvl,"_CODE")
  # First, we discover what GAUL codes are missing from the pixel_spatial table compared to the shapefile:
  shpfile_attributes<-admin_levels[[as.character(lvl)]][["attributes"]] # Get the attribute table from the admin level's shapefile
  shpfile_attributes = subset(shpfile_attributes,ADM0_CODE != 40762)
  attribute_codes<-shpfile_attributes[[paste0("ADM",lvl,"_CODE")]] # Get list of codes for that level from the admin level's attribute table
  admin_cols<-names(shpfile_attributes)[names(shpfile_attributes)%in%c("ADM0_CODE","ADM1_CODE","ADM2_CODE")] # Any columns in ADM0, ADM1, and ADM2_CODE that should be included as merges.
  pixel_codes<-pixel_spatial[[fieldname]] # Get list of codes based on what's in the pixel_spatial object
  missing_codes<-attribute_codes[!(attribute_codes %in% pixel_spatial[[fieldname]])] # Get list of missing codes
  missing_table<-shpfile_attributes[shpfile_attributes[[fieldname]]%in%missing_codes,admin_cols,with=F]
  
  if(length(missing_codes)==0){
    message(paste0("No missing codes at level ",lvl))
  }else{
    message(paste0("Missing codes found for level ",lvl,":"))
    # Strategy 1: Assign a pixel location based on centroid location
    # Develop a raster of the pixel-IDs:
    message("  Discovering centroid location")
    points<-admin_levels[[as.character(lvl)]][["centroids"]] # SpatialPointsDataFrame of that level
    missing_points<-points[(points@data[[fieldname]] %in% missing_codes),] # getting only the missing points
    missing_centroid_locs<-data.table(raster::extract(pixel_id_raster,missing_points)) # Extracting the missing location values as centroid points...
    names(missing_centroid_locs)<-"point_method"
    missing_admins_centroids<-data.table(missing_codes,missing_centroid_locs)
    
    # Strategy 2: Assign a pixel location based on polygon extraction
    # Develop a raster of the pixel-IDs:
    message("  Discovering first raster pixel touching polygon")
    polys<-admin_levels[[as.character(lvl)]][["spdf"]] # SpatialPointsDataFrame of that level
    missing_polys<-polys[(polys@data[[fieldname]] %in% missing_codes),] # getting only the missing points
    missing_poly_locs<-data.table(raster::extract(x=pixel_id_raster,y=missing_polys,small=T,fun=function(x,...)first(x))) # Extracting the missing location values as polygons, pulling the first raster cell that it touches...
    names(missing_poly_locs)<-"poly_method"
    missing_admins_polys<-data.table(missing_codes,missing_poly_locs) # Extracting the
    
    # Merging strategies together: centroids and polygons; adding to list.
    missing_locs<-merge(missing_admins_polys,missing_admins_centroids,by="missing_codes")
    setnames(missing_locs,"missing_codes",fieldname)
    missing_locs<-merge(missing_locs,missing_table,by=fieldname) # Add in admin 0, 1 levels if relevant
    missing_locs[,pixel_id:=point_method] # If centroid produced something, go with centroid
    missing_locs[is.na(point_method),pixel_id:=poly_method] # Otherwise, go with the polygon method.
    
    # For those still missing, assign them to nearest non-NA pixel using centroid
    if(NA %in% missing_locs$pixel_id){
      message('  After centroids and polygon methods, there are still some missing admins.')
      message('  Now sampling to find nearest non-NA pixel and using that')
      
      for(rr in which(is.na(missing_locs$pixel_id))){
        message(sprintf('  -- finding nearest pixel to gaul_code: %i',
                        as.numeric(missing_locs[rr, sprintf('ADM%i_CODE', lvl), with = F])))
        
        ## get centroid of chape
        mp <- polys[polys[[sprintf('ADM%i_CODE', lvl)]] == missing_locs[[sprintf('ADM%i_CODE', lvl)]][rr],]
        cent <- getSpPPolygonsLabptSlots(mp)
        
        ## loop through withh an increasing radius and see if nearby points are non-NA
        found <- 0
        radius <- .005
        while(found != 1 & radius < 1.5){ ## stop for max radius or match found
          ## sample 1000 nearby locs
          near <- matrix(runif(2000, -radius, radius), ncol = 2)
          near[, 1] <- near[, 1] + cent[1, 1]
          near[, 2] <- near[, 2] + cent[1, 2]
          
          ## extract raster pixels
          near <- data.table(raster::extract(pixel_id_raster, near), near)
          colnames(near) <- c('pixel_id', 'x', 'y')
          
          if(mean(is.na(near[,pixel_id])) < 1){ ## then we've found a non-NA neighbor
            found <- 1 ## end while loop
            message(sprintf('  ---- found neighbor using radius: %f', radius))
            
            ## find closest neighbor
            near <- na.omit(near) ## those with non-NA pixels
            dist <- sqrt((near[, x] - cent[1, 1]) ^ 2 +
                           (near[, y] - cent[1, 2]) ^ 2)
            min.ind <- which.min(dist) ## in case of tie, this returns 1st
            
            ## take the pixel id of the nearest sampled neighbor
            missing_locs[rr, pixel_id := near[min.ind, pixel_id] ]
          }
          
          ## increase radius in case we didn't catch anything
          radius <- radius + .005
          
        } ## end while loop
      } ## for each admin with NA pixel_id
    } ## if any NA pixel ids after centroid and poly methods
    
    
    # Check to see if NAs still exist in missing locations, make a warning about missing areas.
    if(NA %in% missing_locs$pixel_id){
      message( "The following admin units appear to be getting lost forever:")
      print(missing_locs[is.na(pixel_id),c("pixel_id",admin_cols),with=F])
    }
    
    # Merging on locations with pixel IDs
    missing_locs<-missing_locs[!is.na(pixel_id),c("pixel_id",admin_cols),with=F]
    missing_locs<-merge(missing_locs,cell_pred[,c("pixel_id","pop","year",draw_colnames),with=F],by="pixel_id",allow.cartesian=T)
    missing_admins[[as.character(lvl)]]<-missing_locs
  }
  
} # For each level...


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Collapsing down draw information using weighted means, based on population.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# For Urban first
cell_pred <- cell_pred_urban
pop       <-  pop_urban

# Making a region-level draws object (we can use this for Africa/Global-level measures
# without being concerned that we have duplicated pixels-- if we used Adm0, 1, 2, etc, we
# would be double-counting pixels that we sampled for admin units that were smaller/did not
# align with a pixel. By creating a region-level one ahead of time, we avoid that problem--
# it means we should use "region" to aggreagate to continent/world/anything higher and nested.)
region<-cell_pred[ADM0_CODE %in% region_adm0_list,lapply(.SD,weighted.mean,w=pop, na.rm=T),by=list(year), .SDcols=draw_colnames]
region[,region_name:=reg]

# Adding in the missing admin information for admin 0, 1, 2...
if("0" %in% names(missing_admins)){adm0<-rbind(cell_pred,missing_admins[["0"]], fill=T)}else{adm0<-copy(cell_pred)}
adm0 <- adm0[ADM0_CODE %in% region_adm0_list,lapply(.SD,weighted.mean,w=pop, na.rm=T),by=list(ADM0_CODE,year), .SDcols=draw_colnames]
if("1" %in% names(missing_admins)){adm1<-rbind(cell_pred,missing_admins[["1"]], fill=T)}else{adm1<-copy(cell_pred)}
adm1 <- adm1[ADM0_CODE %in% region_adm0_list,lapply(.SD,weighted.mean,w=pop, na.rm=T),by=list(ADM1_CODE,year), .SDcols=draw_colnames]
if("2" %in% names(missing_admins)){adm2<-rbind(cell_pred,missing_admins[["2"]], fill=T)}else{adm2<-copy(cell_pred)}
adm2 <- adm2[ADM0_CODE %in% region_adm0_list,lapply(.SD,weighted.mean,w=pop, na.rm=T),by=list(ADM2_CODE,year), .SDcols=draw_colnames]

# Generate total populations for each level, make sure to account for missing admins
pop_region<-pop[ADM0_CODE %in% region_adm0_list,list(pop=sum(pop)),by=list(year)]
pop_region[,region_name:=reg]

pop_adm0<-pop[ADM0_CODE %in% region_adm0_list,list(pop=sum(pop)),by=list(ADM0_CODE,year)]
if ("0" %in% names(missing_admins)) {
  missing_adm0_pops <- subset(missing_admins[["0"]], !(ADM0_CODE %in% pop_adm0$ADM0_CODE), select = c("ADM0_CODE", "year", "pop"))
  pop_adm0 <- rbind(pop_adm0, missing_adm0_pops, use.names = T)
}

pop_adm1<-pop[ADM0_CODE %in% region_adm0_list,list(pop=sum(pop)),by=list(ADM1_CODE,year)]
if ("1" %in% names(missing_admins)) {
  missing_adm1_pops <- subset(missing_admins[["1"]], !(ADM1_CODE %in% pop_adm1$ADM1_CODE), select = c("ADM1_CODE", "year", "pop"))
  pop_adm1 <- rbind(pop_adm1, missing_adm1_pops, use.names = T)
}

pop_adm2<-pop[ADM0_CODE %in% region_adm0_list,list(pop=sum(pop)),by=list(ADM2_CODE,year)]
if ("2" %in% names(missing_admins)) {
  missing_adm2_pops <- subset(missing_admins[["2"]], !(ADM2_CODE %in% pop_adm2$ADM2_CODE), select = c("ADM2_CODE", "year", "pop"))
  pop_adm2 <- rbind(pop_adm2, missing_adm2_pops, use.names = T)
}

# Adding results to the lists of results
regions[[reg]]<-merge(region,pop_region,by=c("year","region_name"))
admin_0[[reg]]<-merge(adm0,pop_adm0,by=c("year","ADM0_CODE"))
admin_1[[reg]]<-merge(adm1,pop_adm1,by=c("year","ADM1_CODE"))
admin_2[[reg]]<-merge(adm2,pop_adm2,by=c("year","ADM2_CODE"))

# Defining the hierarchy of what lives within what:
sp_hierarchy<-unique(admin_levels[["2"]][["attributes"]][,list(ADM0_CODE,ADM1_CODE,ADM2_CODE,ADM0_NAME,ADM1_NAME,ADM2_NAME)])
sp_hierarchy[,region:=reg]
sp_hierarchy_list[[reg]]<-sp_hierarchy

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
# Collapsing and Saving Results ####
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
admin_0<-rbindlist(admin_0)
admin_1<-rbindlist(admin_1)
admin_2<-rbindlist(admin_2)
sp_hierarchy_list<-rbindlist(sp_hierarchy_list)

save(admin_0,admin_1,admin_2,sp_hierarchy_list,
     file=paste0(share_dir, '/urban_rural/urban/', indicator, "_unraked_admin_draws_eb_bin", age, "_", reg, "_", holdout, ".RData"))


# For Rural
regions<-list()
admin_0<-list()
admin_1<-list()
admin_2<-list()
sp_hierarchy_list<-list()

cell_pred <- cell_pred_rural
pop       <-  pop_rural

# Making a region-level draws object (we can use this for Africa/Global-level measures
# without being concerned that we have duplicated pixels-- if we used Adm0, 1, 2, etc, we
# would be double-counting pixels that we sampled for admin units that were smaller/did not
# align with a pixel. By creating a region-level one ahead of time, we avoid that problem--
# it means we should use "region" to aggreagate to continent/world/anything higher and nested.)
region<-cell_pred[ADM0_CODE %in% region_adm0_list,lapply(.SD,weighted.mean,w=pop, na.rm=T),by=list(year), .SDcols=draw_colnames]
region[,region_name:=reg]

# Adding in the missing admin information for admin 0, 1, 2...
if("0" %in% names(missing_admins)){adm0<-rbind(cell_pred,missing_admins[["0"]], fill=T)}else{adm0<-copy(cell_pred)}
adm0 <- adm0[ADM0_CODE %in% region_adm0_list,lapply(.SD,weighted.mean,w=pop, na.rm=T),by=list(ADM0_CODE,year), .SDcols=draw_colnames]
if("1" %in% names(missing_admins)){adm1<-rbind(cell_pred,missing_admins[["1"]], fill=T)}else{adm1<-copy(cell_pred)}
adm1 <- adm1[ADM0_CODE %in% region_adm0_list,lapply(.SD,weighted.mean,w=pop, na.rm=T),by=list(ADM1_CODE,year), .SDcols=draw_colnames]
if("2" %in% names(missing_admins)){adm2<-rbind(cell_pred,missing_admins[["2"]], fill=T)}else{adm2<-copy(cell_pred)}
adm2 <- adm2[ADM0_CODE %in% region_adm0_list,lapply(.SD,weighted.mean,w=pop, na.rm=T),by=list(ADM2_CODE,year), .SDcols=draw_colnames]

# Generate total populations for each level, make sure to account for missing admins
pop_region<-pop[ADM0_CODE %in% region_adm0_list,list(pop=sum(pop)),by=list(year)]
pop_region[,region_name:=reg]

pop_adm0<-pop[ADM0_CODE %in% region_adm0_list,list(pop=sum(pop)),by=list(ADM0_CODE,year)]
if ("0" %in% names(missing_admins)) {
  missing_adm0_pops <- subset(missing_admins[["0"]], !(ADM0_CODE %in% pop_adm0$ADM0_CODE), select = c("ADM0_CODE", "year", "pop"))
  pop_adm0 <- rbind(pop_adm0, missing_adm0_pops, use.names = T)
}

pop_adm1<-pop[ADM0_CODE %in% region_adm0_list,list(pop=sum(pop)),by=list(ADM1_CODE,year)]
if ("1" %in% names(missing_admins)) {
  missing_adm1_pops <- subset(missing_admins[["1"]], !(ADM1_CODE %in% pop_adm1$ADM1_CODE), select = c("ADM1_CODE", "year", "pop"))
  pop_adm1 <- rbind(pop_adm1, missing_adm1_pops, use.names = T)
}

pop_adm2<-pop[ADM0_CODE %in% region_adm0_list,list(pop=sum(pop)),by=list(ADM2_CODE,year)]
if ("2" %in% names(missing_admins)) {
  missing_adm2_pops <- subset(missing_admins[["2"]], !(ADM2_CODE %in% pop_adm2$ADM2_CODE), select = c("ADM2_CODE", "year", "pop"))
  pop_adm2 <- rbind(pop_adm2, missing_adm2_pops, use.names = T)
}

# Adding results to the lists of results
regions[[reg]]<-merge(region,pop_region,by=c("year","region_name"))
admin_0[[reg]]<-merge(adm0,pop_adm0,by=c("year","ADM0_CODE"))
admin_1[[reg]]<-merge(adm1,pop_adm1,by=c("year","ADM1_CODE"))
admin_2[[reg]]<-merge(adm2,pop_adm2,by=c("year","ADM2_CODE"))

# Defining the hierarchy of what lives within what:
sp_hierarchy<-unique(admin_levels[["2"]][["attributes"]][,list(ADM0_CODE,ADM1_CODE,ADM2_CODE,ADM0_NAME,ADM1_NAME,ADM2_NAME)])
sp_hierarchy[,region:=reg]
sp_hierarchy_list[[reg]]<-sp_hierarchy

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
# Collapsing and Saving Results ####
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
admin_0<-rbindlist(admin_0)
admin_1<-rbindlist(admin_1)
admin_2<-rbindlist(admin_2)
sp_hierarchy_list<-rbindlist(sp_hierarchy_list)

save(admin_0,admin_1,admin_2,sp_hierarchy_list,
     file=paste0(share_dir, '/urban_rural/rural/', indicator, "_unraked_admin_draws_eb_bin", age, "_", reg, "_", holdout, ".RData"))


# }
# 
# for(ur in c('urban', 'rural')){
#   
#   combine_aggregation(rd = run_date, 
#                       indic = indicator, 
#                       ig = indicator_group,
#                       ages     = 0,
#                       regions  = c(my_regions, 'dia_name'),
#                       holdouts = 0,
#                       raked    = F,
#                       delete_region_files = F,
#                       dir_to_search = paste0('/ihme/geospatial/mbg/antibiotics/cough_antibiotics/output/2020_02_15_03_49_34/urban_rural/', ur, '/'))
# 
#   output_dir = paste0('/ihme/geospatial/mbg/antibiotics/cough_antibiotics/output/2020_02_15_03_49_34/urban_rural/', ur, '/admin_summaries/')
#   dir.create(output_dir)
#   
#   #summarise admins
#   load(paste0('/ihme/geospatial/mbg/antibiotics/cough_antibiotics/output/2020_02_15_03_49_34/urban_rural/', ur, '/cough_antibiotics_unraked_admin_draws_eb_bin0_0.RData'))
#     
#   sp_hierarchy_list <- mutate_if(sp_hierarchy_list, is.factor, 
#                                    as.character)
#     sp_hierarchy_list <- mutate_at(sp_hierarchy_list, grep("_CODE", 
#                                                            names(sp_hierarchy_list), value = T), as.numeric)
#     for (ad in c(0,1,2)) {
#       ad_summary_table <- make_admin_pred_summary(admin_pred = get(paste0("admin_", 
#                                                                           ad)), sp_hierarchy_list, summary_stats = summstats)
#       fwrite(ad_summary_table, file = paste0(output_dir, 
#                                              indicator, "_admin_", ad, "_summary.csv"))
#   }
# }  
#   
